{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"前端開發如何查看手機瀏覽器的 DevTools (Safari, Chrome)","text":"前言工作專案要開發手機版的 PWA 但每次都覺得 chrome devTools 的 device 模式與實際上手機真的跑的樣式都會有些落差，有時候還會遇到瀏覽器 JavaScript 格式不同或是支援性問題（如 new Date 在 safari 上的上的格式要求 等等）所以想紀錄一篇如何用電腦連動手機瀏覽器，打開手機瀏覽器的 devTools。 iOS 系統 (Safari)手機端的設定手機端要先開啟 Safari 的「網頁檢閱器」。 設定 &gt; Safari &gt; 進階 &gt; 開啟「網頁檢閱器」 然後就可以用 Safari 開啟目標網頁，接著設定電腦端。 電腦端的設定開啟 Safari 後看一下頂端的工具列有沒有「開發」的分頁。如果沒有的話須要先開啟開發選單。 點選「Safari」&gt; 偏好設定 &gt; 進階 &gt; 在選單列中顯示「開發」選單 就會看到選單列出現「開發的分頁」 此時用傳輸線連接手機與電腦，並通過一些權限設定（會自動跳出詢問）就可以再「開發」分頁找到對應的裝置與分頁。 Safari 不愧是新一代 ie ，很多特立獨行的 CSS 樣式或是不支援較新的 Web API。可以查看 devTools 的情況下就可以直接測試手機版上的真實狀況了，如果是使用 PWA 設定將頁面安裝到桌面也可以適用。 Xcode Simulator如果是使用 Mac 其實還可以使用 Xcode 內建的 Simulator 來開啟一個模擬的 iOS 系統，搜尋 Xcode Simulator 就可以看到很多教學文章。測試起來好像是直接在 macOS 上直接建立一個 iOS 確實也是蠻方便的，而且可以切換不同的手機型號來測試不同的 Safari 版本。 Android 系統 (Chrome)各品牌的 Android 手機都有出自家的瀏覽器，但主流開發還是以 Chrome 為主，PWA 也以 Chrome 的支援度最為完整。 手機端的設定手機端的設定蠻有趣的，感覺有點像是找彩蛋一樣依照某些步驟完成隱藏的指令才能開啟「開發者模式」，不同品牌型號的 Android 手機的介面略有差異，但步驟應該都會差不多。 設定 &gt; 關於手機 &gt; 軟體資訊 &gt; 找到「版本號碼」並點擊7下 操作時會有提示告知開發者模式已經開啟，完成後回到「設定」頁就會看到「開發人員選項」的分頁。接著將手機連結傳輸線至電腦就會跳出一些權限相關的問題設定，完成後就開啟 Chrome 並接著設定電腦端。 電腦端的設定打開 Chrome 並輸入網址 chrome://inspect/#devices 就可以看到以下畫面，左側選擇 Devices 而且如果有完成手機連線至電腦的權限設定，就可以看到 Remote Target。 Remote Target 會列出裝置與裝置開啟的瀏覽器、分頁等資訊，找到開發的分頁後點擊 inspect 就可以看到裝置畫面與 Chrome 的 devTools，操作就與電腦版的 Chrome 差異不大了。 總結以整體使用體驗來說我覺得 Android/Chrome 雖然前置步驟稍微複雜一點，但提供開發的體驗與完整性是大勝 Safari 的，iOS 連接 mac 與 Safari 很常會明明都連接到了就是不出現開啟中的分頁或偵測不到。但自從可以查看開發者工具後，大部分的 CSS 跑版問題或 JavaScript 支援性問題都可以獲得解決，我覺得算是開發 PWA 必定要知道的技巧之一。 參考資料 Configure on-device developer options @Android Remote debug Android devices @Google","link":"/2022/03/09/check-mobile-devtool-on-pc/"},{"title":"[解題筆記] LeetCode: Longest Substring Without Repeating Characters (Medium)","text":"前言我其實不太常刷題，這陣子因為面試開始練手感，後來想想只是解題好像有點可惜，應該紀錄一下自己解題的思維，留一個機會讓未來我可以檢視自己有沒有進步；一方面開始練習寫文章，撰文真的好難。 前一陣子摸了基礎的 counter、pointer 用法之後，以為自己面對一些基礎的 algorithm 應該要秒解才對，結果還是花了比預期還要長的時間。我認為就是還不夠熟練，大部分演算法也不是一個公式就可以帶入得到解答，瞭解特定演算法的思維再判斷不同的情境才能順利解題。 題目Given a string s, find the length of the longest substring without repeating characters. Example: Input: s = “pwwkew”Output: 3Explanation: The answer is “wke”, with the length of 3.Notice that the answer must be a substring, “pwke” is a subsequence and not a substring. 暴力解如果沒有 pointer 的概念的話，大概就只能列舉出所有的 substring 組合，並且在每個組合內再跑迴圈檢查是否有重複字串。所以至少需要兩個迴圈來把所有的組合都找出來，然後再執行一個迴圈判斷 substring 有沒有重複，時間複雜度為 𝑂(𝑛3)（彷彿已經聽見 run test 時筆電風扇在轉的聲音） 1234567891011121314151617181920212223242526272829var lengthOfLongestSubstring = function(s) { if (!s.length) return 0; let maxLeng = 0 // 檢查所有的組合 for (let i = 0; i &lt; s.length; i++) { for (let j = i; j &lt; s.length; j++) { if (checkRepeat(s.slice(i, j))) { maxLeng = Math.max(maxLeng, j - i + 1); } } } // 檢查重複 checkRepeat(str) { let map = {} for (let s = 0; s &lt; str.length; s++) { if (!map[str[s]]) { map[str[s]] = true; } else { return true; } } return false; } return maxLeng;} 以前我都會認為「反正先把邏輯寫出來再慢慢優化」就直接暴力解，然後寫完也不知道從何優化起，因為一開始方向不對了啊！現在想想暴力解真的是打咩，發現技術跟心境都有慢慢進步也算是蠻欣慰的⋯ 分析盡力用我很爛的中文以一句話描述題目大概是： 回傳字串 s 當中，最長且不重複的字串長度。 關鍵字明顯是「longest」、「without repeating characters」 第一直覺想到用 map 來找出不重複的字。再來思考最長的長度時有點小卡住，一開始猜想應該是用 pointer，會有兩個指針分別紀錄 start &amp; end，寫出雛型才想起來這就是 Sliding Window 啊。 OK，所以我需要一個物件作為 map，兩個 pointer 以及一個紀錄 maxLength 的變數。接著是邏輯，我用列表的方式把判斷條件列出（其實是不太會寫 pseudocode QQ）： 指針 r 從 index 0 開始往右找，並將跑過的字符紀錄在 map 當中。 檢查 l 與 r 之間的長度是不是大於 maxLeng ？如果是就更新 maxLeng。 如果字符已經在出現過了，map 要移除 l 位置的字符，然後 l 要右移。 統整這些條件後，完整程式碼就出生了： 1234567891011121314151617181920212223var lengthOfLongestSubstring = function(s) { if (!s.length) return 0; let map = {}; let l = 0; let r = 0; let maxLeng = 0; while (r &lt; s.length) { if (!map[s[r]]) { map[s[r]] = true; if (r - l + 1 &gt; maxLeng) { maxLeng = r - l + 1; } r++; } else { delete map[s[l]]; l++; } } return maxLeng}; 使用 Sliding Window 時間複雜度為 𝑂(𝑛)。 更好的解法有寫過 LeetCode 都會知道當你 Submit 答案且通過測試後，LeetCode 會有 Submission Detail 分析你提交的答案，告訴我們花費的時間與記憶題分別優於其他解答多少百分比，以此判斷我們提交的解答是不是還有優化空間。 有一些刷題網站會有討論區，當中就會有人分享自己的寫法 faster than 99.99% 就會好奇看一下是不是有什麼驚為天人的 idea，但也是遇過不少人故意寫來亂的就是了。 後來發現官方也有提供解答方案，其中就有提到 Sliding Window，但還有一個 Sliding Window Optimized 興奮如我必定要來分析紀錄一下還有什麼肉可以啃。 優化參考只有 Java 與 python 的版本，我把它轉為 Javascript 後如下： 12345678910111213141516171819var lengthOfLongestSubstring = function(s) { if (!s.length) return 0; let map = {}; let l = 0; let r = 0; let maxLeng = 0; while (r &lt; s.length) { if (map[s[r]]) { l = Math.max(map[s[r]], l) } maxLeng = Math.max(maxLeng, r - l + 1); map[s[r]] = r + 1; r++; } return maxLeng}; 這個優化的關鍵在於 \bmap 儲存的是字符的 index，而我的原始寫法只是紀錄字符有沒有出現過。差異在於我只能判斷有或沒有，而紀錄 index 可以直接跳過中間不必再檢查的部分。 12345678910111213141516// input: [ A E T C G B C H R ]// map: { A: 1, E: 2, T: 3, C: 4, G: 5, B: 6 }A E T C G B C H R↑ ↑// 遇到了第二個 [C]，原本在 [A] 位置的指針可以直接移到第一個 [C] 之後// map: { A: 1, E: 2, T: 3, C: 7, G: 5, B: 6 }A E T C G B C H R ↑ ↑// 一步一步拆解開就會變這樣.... A E T C G B C .. [ E T C G B C ] [ T C G B C ] // 節省這三步的判斷 [ C G B C ] G B C 儲存 r 的時候有先 +1 再存，應該是為了避免 index 為 0 時 if (map[s[r]]) 會被判定為 false 的緣故。運用 HashMap 的概念，當有字符重複時就直接將 l 指定為先前紀錄的 index 的下一個位置（儲存之前已經 +1 過了），這樣就可以跳過中間不需要重複判斷的部分。 另一個我發現的小技巧是以 Math.max 來取代 if。好處是減少使用一個比較運算符（operator）版面也變得更簡潔，但邏輯不變。l 的計算也改用 Math.max 來取代。 123456// 如果 a &gt; b 就讓 b 的值更新為 aif (newValue &gt; maxLeng) { maxLeng = newValue;}// 等同於maxLeng = Math.max(maxLeng, newValue); 優化後的時間複雜度一樣是 𝑂(𝑛)。兩者的差異在於最糟的情況下(the worse case)： 一般的 Sliding Window 時間複雜度為 𝑂(2𝑛) 優化後 Sliding Window 時間複雜度為 𝑂(𝑛) 但這邊只是想做個簡單的紀錄，就不深究 Big O 相關的定義。 總結我一直把 Sliding Window 當作 pointer 的變體或延伸應用來看，但實際上比起 counter、pointer 好像更需要一些畫面的想像力，這樣在跑邏輯的時候應該更容易明白現在跑到哪一步了，下一步又是什麼情況。（*Heap Sort：有人提到想像力嗎？） 希望自己解題筆記的系列可以持續，也希望今年可以進步到有能力寫技術文章，就不把它當作什麼新年願望了，第一步踩下去持續做才會有收穫。 參考資料 Longest Substring Without Repeating Characters @LeetCode Subarrays with K Different Integers @LeetCode Maximum Erasure Value @LeetCode","link":"/2022/01/12/leetcode-longest-substring-without-repeating-characters/"},{"title":"[解題筆記] LeetCode: Longest Palindromic Substring (Medium)","text":"題目Given a string s, return the longest palindromic substring in s. Example 1: Input: s = “babad”Output: “bab”Explanation: “aba” is also a valid answer. Example 2: Input: s = “cbbd”Output: “bb” 分析題目中 palindromic 是 回文 的意思。最短的回文就是單一個字母，題目就是要在一串隨機字串中找出最長的回文。 根據題目的要求我覺得蠻符合 Sliding Window 的 pattern，所以我會試著先用 Sliding Window 的概念著手。 在 Sliding Window 的迴圈中需要一個檢查回文的判斷，因為這個檢查可能沒辦法一行解決，所以另外寫成一個 function。如果符合回文則暫存字串；如果不符合則縮小 window 的範圍。所以會有幾個條件： window 圈選的範圍字串是否符合回文的條件？ window 是否還能繼續擴大？（是不是已經檢查完所有字符） window 右邊已經擴張到盡頭，左邊要縮小重新新一輪檢查 12345678910111213141516171819202122232425262728293031var longestPalindrome = function(s) { if (s.length === 1) return s; let l = 0, r = 0; // [註1] let str = ''; // [註2] while (l &lt; s.length - 1) { // 符合回文 if (checkPalindrome(s.slice(l, r + 1))) { if ((r - l) &gt; str.length) { str = s.slice(l, r + 1) } r &lt; s.length ? r++ : l++; } // 不符合回文 而且 window 已經無法再擴張 // window 左邊內縮 開始新的判斷 else if (r === s.length) { l++; // [註3] r = l + 1; } // 不符合回文 就擴張 window else { r++; } } return str;}; 檢查回文的 function 我沒有想到比較特別的寫法，就是跑一個迴圈檢查頭尾字符是否相同。 1234567891011function checkPalindrome(s) { if (s.length === 1) return true; let i = 0; while (i &lt; Math.floor(s.length / 2)) { if (s[i] !== s[s.length - i - 1]) { return false; } i++; } return true; } 優化完成基本的邏輯後，我覺得某些地方可以進行優化，減少迴圈的次數。 原本宣告一個 str 來紀錄目前找到最長的回文，但每次紀錄都要執行一次 Array.slice。改為紀錄位置，最後要輸出的時候只要做一次 Array.slice 就好。（註1） 在 while 的條件增加判斷 (l + strPosR - strPosL) &lt; s.length 表示如果左邊的邊界加上當前找到的字傳長度，已經大於 s 的長度，代表已經找不到更長的結果了，可以提前結束迴圈。（註2） 從新一輪的判斷，r 原本是從 l 旁邊開始，但是其實要找最長的回文，就不需要檢查找比現在回文還要短的可能性。（註3） 優化後長這樣： 1234567891011121314151617181920212223var longestPalindrome = function(s) { if (s.length === 1) return s; let l = 0, r = 0; let strPosL = 0, strPosR = 0; while (l &lt; s.length - 1 &amp;&amp; (l + strPosR - strPosL) &lt; s.length) { if (checkPalindrome(s.slice(l, r + 1))) { if ((r - l) &gt; strPosR - strPosL) { strPosL = l; strPosR = r; } r &lt; s.length ? r++ : l++; } else if (r === s.length) { l++; r = l + strPosR - strPosL; } else { r++; } } return s.slice(strPosL, strPosR + 1);}; 總結解完之後其實比我預期的還花時間！光整個邏輯要想清楚要考慮的條件蠻多的，解完題後每隔一段時間就再重頭思考一次邏輯流程，才越來越清楚，以及想到可以優化的地方。完成後我覺得對 Sliding Window 的概念又更熟悉了一些，會讓我想再找是不是還有更複雜的 Sliding Window 來挑戰看看！ 參考資料 Longest Palindromic Substring @LeetCode","link":"/2022/02/01/leetcode-longest-palindromic-substring/"},{"title":"[解題筆記] LeetCode: Median Of Two Sorted Arrays (Hard)","text":"前言一直以來都覺得 Medium 的題目好像就蠻難的，所以也沒有刻意想去挑戰 Hard，這次是上次的題目寫完接著寫下一題，寫完覺得沒有真的很難，也許這題是例外吧，總之順手紀錄一下心得。 題目Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example: Input: nums1 = [1,2], nums2 = [3,4]Output: 2.50000Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. 分析題目的 the median 用粗體標示，對這個單字沒什麼印象於是稍微查了一下，原來是指 中位數。來自維基百科的定義： ⋯⋯如果數據的個數是奇數，則中間那個數據就是這群數據的中位數；如果數據的個數是偶數，則中間那2個數據的算術平均值就是這群數據的中位數。 搭配題目的要求，就是希望取得兩個陣列合併後的中間那一項的值，如果是陣列長度是偶數那就是中間兩項的平均。到這邊我想到兩種做法： 看到兩個陣列合併就想到 Merge Sort，但仔細看題目發現 nums1 與 nums2 都是 sorted array，所以只靠 pointer 就可以合併，合併後取得中間值。 直接把兩個陣列合併起來後 sort()，然後取得中間值。 Pointer1234567891011121314151617181920212223242526272829var findMedianSortedArrays = function(nums1, nums2) { if ((nums1.length + nums2.length) &lt;= 1) { return nums1[0] || nums2[0] || 0 } let mergedArray = [] let i = 0, j = 0 while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) { if (nums1[i] &lt; nums2[j]) { mergedArray.push(nums1[i]); i++; } else { mergedArray.push(nums2[j]); j++; } } if (i &lt; nums1.length) { mergedArray.push(...nums1.slice(i)); } if (j &lt; nums2.length) { mergedArray.push(...nums2.slice(j)); } return mergedArray.length % 2 === 0 ? (mergedArray[mergedArray.length / 2 - 1] + mergedArray[mergedArray.length / 2]) / 2 : mergedArray[(mergedArray.length - 1) / 2]} 算是簡化版的 merge sort 寫法，while loop 比較 nums1 與 nums2 的大小，當 i, j 其中一個指針已經比較完，代表另一個數列剩下的數都是更大的值，直接推進 mergedArray 就完成兩個數列的合併。需要注意的是 nums1 與 nums2 必須是 sorted array，如果兩個陣列都沒有排序過，就要使用 merge sort。 Array.sort()12345678var findMedianSortedArrays = function(nums1, nums2) { let merged = [...nums1, ...nums2] merged.sort((a, b) =&gt; a - b) return merged.length % 2 === 0 ? (merged[merged.length / 2 - 1] + merged[merged.length / 2]) / 2 : merged[(merged.length - 1) / 2]} 簡單快速，覺得好像沒什麼好紀錄的。有時候看過一些題目有明確限制不能使用原生的 methods，但這題沒有所以直接用 sort() 也可以成功的 submission。 After SubmissionSubmission 之後看到的效能數字其實沒有很好，大概都在 50% 以下。但是同一個解答多提交幾次發現效能數字落差蠻大的，我猜可能是有 random test case。我還是去看了一下 Runtime 與 Memory 效能較優異的寫法，發現 Runtime 表現較好的就是使用 Array.sort()，發現 Runtime 表現較好的就是 Pointer 的寫法，而且跟我寫的邏輯幾乎一樣，沒有太大的差異。 總結思考的時候其實有點懷疑，題目是給兩個 sorted array，會不會給兩個 random array 更能符合 Hard 的等級。如果是 random array 其實就很明確是想考 Merge Sort？不過其實不管有沒有先 sorted，第二種方式其實都能完成功能。 題外話，這讓我想到一個有趣的問題：JavaScript 到底是用哪一種演算法實作 sort()？結果讓我發現了一個新名詞 TimSort。稍微看了一下別人的分析，很有趣！但應該不是現階段的我能夠 handle 的，有機會再來讀看看 source code。 參考資料 Median Of Two Sorted Arrays @LeetCode","link":"/2022/01/19/leetcode-median-of-two-sorted-arrays/"},{"title":"前端作品集","text":"整理了寫過的一些專案、作品，紀錄使用的技術與心得 作品集臺北捷運路線查詢 TRTC Route Map 核心功能： 查詢臺北捷運路線、站別出口資訊 查詢路線 geojson 搭配 leaflet 呈現在地圖上 支援社群帳號登入，未來可以擴展使用者面向的功能，站點儲存、查詢記錄等 使用技術 &amp; Library： Vue3 (build with Vite) Element Plus (UI framework, element-ui for vue3) leaflet.js (maps library) Google login api (official sdk) Facebook login api (official sdk) vue3 推出後試寫的作品，主要想熟悉一下 vue3 的語法與差異性。原本是從某次面試作業指定使用 leaflet 實作 polygon, geojson 相關的功能，後來改成介接捷運資料查詢。 實作與社群平台提供的 api 互動，從申請 token id、爬 developer docs 實作登入、取得使用者資訊的功能、專案後台的管理等等，熟悉整個流程。 另外做了一些嘗試，原本的 google login 是看官方文件提供的登入按鈕實作的，相對簡單，後來看到 vue3、react 都支援 hooks 的寫法，對應 vue2 就是 mixins 但是改善了原本可能有的缺點，所以就參考了 VueUse 改寫 google, facebook 的登入、登出相關功能打包成 hooks 的寫法。 臺北捷運路線查詢 TRTC Route MapGithub: https://github.com/memorysd2013/trtc-route-mapDemo Site: https://memorysd2013.github.io/trtc-route-map Vue3 + TypeScript 切版核心功能： 客制化 Element Plus 樣式 bar chart, debounce resize RWD 使用技術 &amp; Library： Vue3 (build with Vite) TypeScript Sass Element Plus (UI framework, element-ui for vue3) Apache ECharts (charts library) Day.js 也是面試作業之一。作業題目是一張 layout 圖片，指定使用 vite + element-plus + typescript 刻出一樣的畫面，盡量考慮 RWD 但沒有要求特殊功能。 使用 Apache ECharts 實作長條圖，大部分的組件是 Element Plus 修改 scss 變數或自訂 style 來符合設計稿外觀，RWD 沒有指定尺寸所以以不跑版為主，視窗寬度縮小至 768px 以下時會自訂收合側邊欄以提供更大的主畫面。 資料的部分使用 Promise 與 Math.random 模擬 api 資料操作，切換畫面的按鈕參數時會自動代換數值。因為開發的時間比較短，理想中是 api function 分離的更清楚，當有測試或實際可使用的 api 只需要指定 api 路徑就可以套用整個專案。 圖表組件一樣練習用 hooks 的寫法 (src/hook/useBar.ts) 管理圖表的生命週期，並暴露一個 resize 的 function 來達成圖表 RWD。resize 綁定在 window resize 的 event 上，並使用 debounce 來避免視窗尺寸變動時連續觸發太多次事件，預設防抖 500 毫秒後才會觸發 resize。 Vue3 + TypeScript 切版Github: https://github.com/memorysd2013/ts-layoutDemo Site: https://memorysd2013.github.io/ts-layout Side Projecteq-calendar-vue2核心功能： 客製化日曆、週曆、月曆組件，支援 RWD 使用 Vue slot 可以在組件內放入自訂內容 使用技術 &amp; Library： Vue2 (build with Vue CLI) Day.js 用於公司內部專案的班表系統，因為需要客製化功能與樣式，所以就不使用現有套件選擇直接重刻。發布至 npm 主要是管理讓公司內部多個專案使用。 eq-calendar-vue2Github: https://github.com/memorysd2013/eq-calendar-vue2Demo Site: https://memorysd2013.github.io/eq-calendar-vue2npm: https://www.npmjs.com/package/eq-calendar-vue2 OthersGoogle Extension: Youtube Transmission 核心功能： 抓取網頁中 youtube 影片元素可以自訂加/減速、迴圈播放等。 使用技術： HTML, CSS, JavaScript Google Extension Docs \b無意間看到 Google Extension 的教學文章，花了一些時間研究後完成的作品。想法發想是我自己常使用 youtube 的影片來練習吉他，因為要靠耳朵聽出和弦或是樂句，很常依賴 youtube 的設定/播放速度來放慢速度。youtube 提供的選項只有 0.75、0.5、0.25 (後來發現其實可以自訂)，於是我就想做出可以選擇更小單位的速度調節插件，時間區間重複播放的功能也蠻常用到的，就試著把迴圈功能加上。 插件本身可以視為一個獨立的頁面，透過 message 或是 contect 的方式與主網頁互動，這樣的溝通方式我覺得跟 worker 有一點像。因為可以直接跟主網頁互動，所以其實限制蠻多的，比如沒辦法輕易地把 function 拆分成很多 js 檔再引入，與主網頁的互動也需要在 manifest 設定權限，並在發布時描述申請這些權限的用意。 這次開發除了累積閱讀英文文件的經驗以外，另一個給我比較大的收穫是 UX 的部分，因為自己就是使用者，完全地以實際使用的情況、會遇到的問題、怎麼樣的體驗或是流程是自己需要的方向去開發跟思考。作品完成上架後，我也分享給朋友使用並得到一些回饋，讓我覺得蠻有成就感的，雖然不是很困難或很複雜的作品，但可以實際得到使用者回饋是一個蠻特別的體驗。 Demo: Youtube TransmissionGithub: https://github.com/memorysd2013/youtube-transmissionGoogle webstore: https://chrome.google.com/webstore/detail/youtube-transmission/jaaokfelcbloneeeaanalpkealibhfan?hl=zh-TW Codepen: Memory Match Game with Vue3試玩 Vue3 寫出來的小東西，自己蠻喜歡的。 Codepen: Bubble Sort Animation前一陣子接觸入門演算法時看到很多網站用動畫去解釋排序法，覺得蠻有趣的，於是用氣泡排序法試著寫看看。只用 JavaScript 沒有用任何框架套件，動畫用 CSS transform 實現。 Codepen: Quicksort Practice with Vue3剛接觸 Quicksort 的時候沒有很懂整個邏輯，於是也試著自己寫一遍。","link":"/2022/04/01/portfolio/"},{"title":"Promise 應用紀錄","text":"整理一些 Promise 相關的觀念與問題。文內節錄自 promise 問題集 重點整理 瀏覽器的 window 有一個 Promise，可以直接使用 .resolve .reject .race .all。 一般建立 Promise 需要用 new 並且需要指定 resolve 否則會報錯。 Promise.then 只有在 resolve \b被執行後才會執行（.catch 同理）。 .finally 有 resolve 或 reject 執行後會跟著執行，換句話說沒有執行 resolve 或 reject，finally 也不會執行。 基礎題型question1-1 1234const promise1 = new Promise((resolve, reject) =&gt; { console.log('promise1')})console.log('1', promise1); question2-2 123456789const promise = new Promise((resolve, reject) =&gt; { console.log(1); resolve('success') console.log(2);});promise.then(() =&gt; { console.log(3);});console.log(4); question3-3 12345678const promise = new Promise((resolve, reject) =&gt; { console.log(1); console.log(2);});promise.then(() =&gt; { console.log(3);});console.log(4); question4-4 123456789const promise1 = new Promise((resolve, reject) =&gt; { console.log('promise1') resolve('resolve1')})const promise2 = promise1.then(res =&gt; { console.log(res)})console.log('1', promise1);console.log('2', promise2); hint: Promise.then 會回傳一個 promise promise.then 其實可以有兩個參數 兩個都是 function 分別對應 promise 的 resolve 與 reject question5-5 123456789const fn = () =&gt; (new Promise((resolve, reject) =&gt; { console.log(1); resolve('success')}))fn().then(res =&gt; { console.log(res)})console.log('start') Promise with setTimeoutquestion1-1 12345678console.log('start')setTimeout(() =&gt; { console.log('time')})Promise.resolve().then(() =&gt; { console.log('resolve')})console.log('end') question2-2 12345678910111213const promise = new Promise((resolve, reject) =&gt; {console.log(1);setTimeout(() =&gt; { console.log(\"timerStart\"); resolve(\"success\"); console.log(\"timerEnd\");}, 0);console.log(2);});promise.then((res) =&gt; { console.log(res);});console.log(4); hint: promise.then((res) =&gt; {}) (用 \bnew Promise 建構的) 與 Promise.resolve().then(() =&gt; {}) 要分清楚 沒有執行 resolve 之前, then 不會被執行 question3-3 12345678910111213Promise.resolve().then(() =&gt; { console.log('promise1'); const timer2 = setTimeout(() =&gt; { console.log('timer2') }, 0)});const timer1 = setTimeout(() =&gt; { console.log('timer1') Promise.resolve().then(() =&gt; { console.log('promise2') })}, 0)console.log('start'); question4-4 1234567891011121314151617const promise1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(\"success\"); console.log(\"timer1\"); }, 1000); console.log(\"promise1裡的內容\");});const promise2 = promise1.then(() =&gt; { throw new Error(\"error!!!\");});console.log(\"promise1\", promise1);console.log(\"promise2\", promise2);setTimeout(() =&gt; { console.log(\"timer2\"); console.log(\"promise1\", promise1); console.log(\"promise2\", promise2);}, 2000); ANSWERanswer1-1 ‘promise1’‘1’ Promise{&lt;pending&gt;} answer1-2 1 2 4 3 answer1-3 1 2 4 answer1-4 ‘promise1’‘1’ Promise{&lt;resolved&gt;: ‘resolve1’}‘2’ Promise{&lt;pending&gt;}‘resolve1’ answer1-5 1‘start’‘success’ answer2-1 ‘start’‘end’‘resolve’‘time’ answer2-2 124‘timerStart’‘timerEnd’‘success’ answer2-3 ‘start’‘promise1’‘timer1’‘promise2’‘timer2’ answer2-4 ‘promise1裡的內容’‘promise1’ Promise{}‘promise2’ Promise{}‘timer1’Uncaught (in promise) Error: error!!!‘timer2’‘promise1’ Promise{: “success”}‘promise2’ Promise{: Error: error!!!}","link":"/2022/06/26/promise/"},{"title":"加密貨幣研究筆記","text":"Stablecoin 穩定幣穩定幣是加密貨幣的一種，藉由穩定資產的特性來維持幣值的波動性，具有加密貨幣的特性且波動性較小。 因為其價值相對穩定的特性，常見於交易對或是作為加密貨幣中的避險資產。最知名的穩定幣為 USDT（Tether 泰達幣）就是錨定美金的一種穩定幣，幾乎可視為與美金 1:1 兌換。 Pair 交易對由兩種不同的加密貨幣組成，作為加密貨幣間的價值基準判定，格式如： BTC/USDT ETH/BTC ADA/BUSD 當持有交易對中其中一種加密貨幣，就可以依照這個交易對來交易另一種加密貨幣。通常後項會是主流幣（BTC, ETH）、穩定幣或交易所發行的平台幣。 DeFi 去中心化金融DeFi 為 Decentralized Finance 的縮寫，解釋為建立在區塊鏈技術上的金融服務，如買賣、借貸、保險。 因為具有去中心化的特性，交易雙方可進行不受監管的金融活動，也因此不少人認為有其風險，是近年討論度非常高的加密貨幣機制。 對應傳統的中心化金融服務即為 CeFi（Centralize Finance）。 DeFi是什麼？去中心化金融DeFi跟CeFi差別在哪？DeFi 野蠻生長，法規監管跟得上「幣圈華爾街」的技術突破速度嗎？ PoW 工作量證明Proof of Work。利用電腦算力爭取驗證下一個區塊鏈的節點。工作量越大，得到的挖礦獎勵越多。 比特幣、以太坊 1.0 即是使用 PoW 這種機制，因為耗電量大、過度消耗硬體資源進而發展 PoS。 PoS 權益證明Proof of Stake。採取 PoS 機制的區塊鏈，系統會根據質押的加密貨幣數量來選出下一個區塊鏈結點的驗證者。質押的數量越多、時間越長，越有機會被選為驗證者。 以太坊 2.0、幣安幣即是採用 PoS 機制的區塊鏈，缺點為可能造成加幣貨幣囤積。 DPos 代理權益證明Delegated Proof of Stake。DPos 與 PoS 原理雷同，只是改為代理權益證明作為共識機制。與 PoS 的差異還有 DPoS 會票選出多個代理人，代理人將負責記帳和驗證。 擁有比 PoW、PoS 更高的效率、更低的功耗。但是以代理人共識取代全鏈共識的特性，有與區塊鏈去中心化的理念相違背的爭議。 桑幣知識+ 權益授權證明 DPoS (Delegated Proof of Stake) Staking 質押加密貨幣可以質押給驗證人，質押期間這些加密貨幣無法買賣交易。質押期間可以收取手續費，但依然要承受幣值浮動的風險。 每一種加密貨幣的質押規則、利息、解倉時間都不一定，各個交易所也會提供不同的衍生方式。 Perpetual 永續合約永續合約又稱合約、永續期貨合約。合約可以僅用小額度的保證金以槓桿的方式放大投資損益，而永續合約顧名思義只要不爆倉，該合約就一直有效。 爆倉：幣價漲跌幅 x 槓桿倍數 &gt; 100%。即合約終止，所有保證金歸零 一般在股市而言，期貨除了開槓桿加倍獲利也常用於避險，而加密貨幣交易的合約通常就是追求高倍數獲利之用。 腦哥 Chill塊鏈 虛擬貨幣合約交易操作解析","link":"/2021/12/26/question-about-crypto/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"front-end","slug":"front-end","link":"/tags/front-end/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"safari","slug":"safari","link":"/tags/safari/"},{"name":"ios","slug":"ios","link":"/tags/ios/"},{"name":"pwa","slug":"pwa","link":"/tags/pwa/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"}],"categories":[{"name":"front-end","slug":"front-end","link":"/categories/front-end/"},{"name":"crypto","slug":"crypto","link":"/categories/crypto/"}]}
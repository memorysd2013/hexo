{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"[解題筆記] LeetCode: Longest Substring Without Repeating Characters (Medium)","text":"前言我其實不太常刷題，這陣子因為面試開始練手感，後來想想只是解題好像有點可惜，應該紀錄一下自己解題的思維，留一個機會讓未來我可以檢視自己有沒有進步；一方面開始練習寫文章，撰文真的好難。 前一陣子摸了基礎的 counter、pointer 用法之後，以為自己面對一些基礎的 algorithm 應該要秒解才對，結果還是花了比預期還要長的時間。我認為就是還不夠熟練，大部分演算法也不是一個公式就可以帶入得到解答，瞭解特定演算法的思維再判斷不同的情境才能順利解題。 題目Given a string s, find the length of the longest substring without repeating characters. Example: Input: s = “pwwkew”Output: 3Explanation: The answer is “wke”, with the length of 3.Notice that the answer must be a substring, “pwke” is a subsequence and not a substring. （⋯更詳細的 example 與條件可以參照 LeetCode 原題目） 暴力解如果沒有 pointer 的概念的話，大概就只能列舉出所有的 substring 組合，並且在每個組合內再跑迴圈檢查是否有重複字串。所以至少需要兩個迴圈來把所有的組合都找出來，然後再執行一個迴圈判斷 substring 有沒有重複，時間複雜度為 𝑂(𝑛3)（彷彿已經聽見 run test 時筆電風扇在轉的聲音） 1234567891011121314151617181920212223242526272829var lengthOfLongestSubstring = function(s) { if (!s.length) return 0; let maxLeng = 0 // 檢查所有的組合 for (let i = 0; i &lt; s.length; i++) { for (let j = i; j &lt; s.length; j++) { if (checkRepeat(s.slice(i, j))) { maxLeng = Math.max(maxLeng, j - i + 1); } } } // 檢查重複 checkRepeat(str) { let map = {} for (let s = 0; s &lt; str.length; s++) { if (!map[str[s]]) { map[str[s]] = true; } else { return true; } } return false; } return maxLeng;} 以前我都會認為「反正先把邏輯寫出來再慢慢優化」就直接暴力解，然後寫完也不知道從何優化起，因為一開始方向不對了啊！現在想想暴力解真的是打咩，發現技術跟心境都有慢慢進步也算是蠻欣慰的⋯ 分析盡力用我很爛的中文以一句話描述題目大概是： 回傳字串 s 當中，最長且不重複的字串長度。 關鍵字明顯是「longest」、「without repeating characters」 第一直覺想到用 map 來找出不重複的字。再來思考最長的長度時有點小卡住，一開始猜想應該是用 pointer，會有兩個指針分別紀錄 start &amp; end，寫出雛型才想起來這就是 Sliding Window 啊。 OK，所以我需要一個物件作為 map，兩個 pointer 以及一個紀錄 maxLength 的變數。接著是邏輯，我用列表的方式把判斷條件列出（其實是不太會寫 pseudocode QQ）： 指針 r 從 index 0 開始往右找，並將跑過的字符紀錄在 map 當中。 檢查 l 與 r 之間的長度是不是大於 maxLeng ？如果是就更新 maxLeng。 如果字符已經在出現過了，map 要移除 l 位置的字符，然後 l 要右移。 統整這些條件後，完整程式碼就出生了： 1234567891011121314151617181920212223var lengthOfLongestSubstring = function(s) { if (!s.length) return 0; let map = {}; let l = 0; let r = 0; let maxLeng = 0; while (r &lt; s.length) { if (!map[s[r]]) { map[s[r]] = true; if (r - l + 1 &gt; maxLeng) { maxLeng = r - l + 1; } r++; } else { delete map[s[l]]; l++; } } return maxLeng}; 使用 Sliding Window 時間複雜度為 𝑂(𝑛)。 更好的解法有寫過 LeetCode 都會知道當你 Submit 答案且通過測試後，LeetCode 會有 Submission Detail 分析你提交的答案，告訴我們花費的時間與記憶題分別優於其他解答多少百分比，以此判斷我們提交的解答是不是還有優化空間。 有一些刷題網站會有討論區，當中就會有人分享自己的寫法 faster than 99.99% 就會好奇看一下是不是有什麼驚為天人的 idea，但也是遇過不少人故意寫來亂的就是了。 後來發現官方也有提供解答方案，其中就有提到 Sliding Window，但還有一個 Sliding Window Optimized 興奮如我必定要來分析紀錄一下還有什麼肉可以啃。 優化參考只有 Java 與 python 的版本，我把它轉為 Javascript 後如下： 12345678910111213141516171819var lengthOfLongestSubstring = function(s) { if (!s.length) return 0; let map = {}; let l = 0; let r = 0; let maxLeng = 0; while (r &lt; s.length) { if (map[s[r]]) { l = Math.max(map[s[r]], l) } maxLeng = Math.max(maxLeng, r - l + 1); map[s[r]] = r + 1; r++; } return maxLeng}; 這個優化的關鍵在於 \bmap 儲存的是字符的 index，而我的原始寫法只是紀錄字符有沒有出現過。差異在於我只能判斷有或沒有，而紀錄 index 可以直接跳過中間不必再檢查的部分。 12345678910111213141516// input: [ A E T C G B C H R ]// map: { A: 1, E: 2, T: 3, C: 4, G: 5, B: 6 }A E T C G B C H R↑ ↑// 遇到了第二個 [C]，原本在 [A] 位置的指針可以直接移到第一個 [C] 之後// map: { A: 1, E: 2, T: 3, C: 7, G: 5, B: 6 }A E T C G B C H R ↑ ↑// 一步一步拆解開就會變這樣.... A E T C G B C .. [ E T C G B C ] [ T C G B C ] // 節省這三步的判斷 [ C G B C ] G B C 儲存 r 的時候有先 +1 再存，應該是為了避免 index 為 0 時 if (map[s[r]]) 會被判定為 false 的緣故。運用 HashMap 的概念，當有字符重複時就直接將 l 指定為先前紀錄的 index 的下一個位置（儲存之前已經 +1 過了），這樣就可以跳過中間不需要重複判斷的部分。 另一個我發現的小技巧是以 Math.max 來取代 if。好處是減少使用一個比較運算符（operator）版面也變得更簡潔，但邏輯不變。l 的計算也改用 Math.max 來取代。 123456// 如果 a &gt; b 就讓 b 的值更新為 aif (newValue &gt; maxLeng) { maxLeng = newValue;}// 等同於maxLeng = Math.max(maxLeng, newValue); 優化後的時間複雜度一樣是 𝑂(𝑛)。兩者的差異在於最糟的情況下(the worse case)： 一般的 Sliding Window 時間複雜度為 𝑂(2𝑛) 優化後 Sliding Window 時間複雜度為 𝑂(𝑛) 但這邊只是想做個簡單的紀錄，就不深究 Big O 相關的定義。 總結我一直把 Sliding Window 當作 pointer 的變體或延伸應用來看，但實際上比起 counter、pointer 好像更需要一些畫面的想像力，這樣在跑邏輯的時候應該更容易明白現在跑到哪一步了，下一步又是什麼情況。（*Heap Sort：有人提到想像力嗎？） 希望自己解題筆記的系列可以持續，也希望今年可以進步到有能力寫技術文章，就不把它當作什麼新年願望了，第一步踩下去持續做才會有收穫。 Source:Longest Substring Without Repeating Characters Similar Questions:Subarrays with K Different IntegersMaximum Erasure Value","link":"/2022/01/12/leetcode-longest-substring-without-repeating-characters/"},{"title":"[解題筆記] LeetCode: Median Of Two Sorted Arrays (Hard)","text":"前言一直以來都覺得 Medium 的題目好像就蠻難的，所以也沒有刻意想去挑戰 Hard，這次是上次的題目寫完接著寫下一題，寫完覺得沒有真的很難，也許這題是例外吧，總之順手紀錄一下心得。 題目Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example: Input: nums1 = [1,2], nums2 = [3,4]Output: 2.50000Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. 分析題目的 the median 用粗體標示，對這個單字沒什麼印象於是稍微查了一下，原來是指 中位數。來自維基百科的定義： ⋯⋯如果數據的個數是奇數，則中間那個數據就是這群數據的中位數；如果數據的個數是偶數，則中間那2個數據的算術平均值就是這群數據的中位數。 搭配題目的要求，就是希望取得兩個陣列合併後的中間那一項的值，如果是陣列長度是偶數那就是中間兩項的平均。到這邊我想到兩種做法： 看到兩個陣列合併就想到 Merge Sort，但仔細看題目發現 nums1 與 nums2 都是 sorted array，所以只靠 pointer 就可以合併，合併後取得中間值。 直接把兩個陣列合併起來後 sort()，然後取得中間值。 Pointer1234567891011121314151617181920212223242526272829var findMedianSortedArrays = function(nums1, nums2) { if ((nums1.length + nums2.length) &lt;= 1) { return nums1[0] || nums2[0] || 0 } let mergedArray = [] let i = 0, j = 0 while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) { if (nums1[i] &lt; nums2[j]) { mergedArray.push(nums1[i]); i++; } else { mergedArray.push(nums2[j]); j++; } } if (i &lt; nums1.length) { mergedArray.push(...nums1.slice(i)); } if (j &lt; nums2.length) { mergedArray.push(...nums2.slice(j)); } return mergedArray.length % 2 === 0 ? (mergedArray[mergedArray.length / 2 - 1] + mergedArray[mergedArray.length / 2]) / 2 : mergedArray[(mergedArray.length - 1) / 2]} 算是簡化版的 merge sort 寫法，while loop 比較 nums1 與 nums2 的大小，當 i, j 其中一個指針已經比較完，代表另一個數列剩下的數都是更大的值，直接推進 mergedArray 就完成兩個數列的合併。需要注意的是 nums1 與 nums2 必須是 sorted array，如果兩個陣列都沒有排序過，就要使用 merge sort。 Array.sort()12345678var findMedianSortedArrays = function(nums1, nums2) { let merged = [...nums1, ...nums2] merged.sort((a, b) =&gt; a - b) return merged.length % 2 === 0 ? (merged[merged.length / 2 - 1] + merged[merged.length / 2]) / 2 : merged[(merged.length - 1) / 2]} 簡單快速，覺得好像沒什麼好紀錄的。有時候看過一些題目有明確限制不能使用原生的 methods，但這題沒有所以直接用 sort() 也可以成功的 submission。 After SubmissionSubmission 之後看到的效能數字其實沒有很好，大概都在 50% 以下。但是同一個解答多提交幾次發現效能數字落差蠻大的，我猜可能是有 random test case。我還是去看了一下 Runtime 與 Memory 效能較優異的寫法，發現 Runtime 表現較好的就是使用 Array.sort()，發現 Runtime 表現較好的就是 Pointer 的寫法，而且跟我寫的邏輯幾乎一樣，沒有太大的差異。 總結思考的時候其實有點懷疑，題目是給兩個 sorted array，會不會給兩個 random array 更能符合 Hard 的等級。如果是 random array 其實就很明確是想考 Merge Sort？不過其實不管有沒有先 sorted，第二種方式其實都能完成功能。 題外話，這讓我想到一個有趣的問題：JavaScript 到底是用哪一種演算法實作 sort()？結果讓我發現了一個新名詞 TimSort。稍微看了一下別人的分析，很有趣！但應該不是現階段的我能夠 handle 的，有機會再來讀看看 source code。","link":"/2022/01/19/leetcode-median-of-two-sorted-arrays/"},{"title":"加密貨幣研究筆記","text":"Stablecoin 穩定幣穩定幣是加密貨幣的一種，藉由穩定資產的特性來維持幣值的波動性，具有加密貨幣的特性且波動性較小。 因為其價值相對穩定的特性，常見於交易對或是作為加密貨幣中的避險資產。最知名的穩定幣為 USDT（Tether 泰達幣）就是錨定美金的一種穩定幣，幾乎可視為與美金 1:1 兌換。 Pair 交易對由兩種不同的加密貨幣組成，作為加密貨幣間的價值基準判定，格式如： BTC/USDT ETH/BTC ADA/BUSD 當持有交易對中其中一種加密貨幣，就可以依照這個交易對來交易另一種加密貨幣。通常後項會是主流幣（BTC, ETH）、穩定幣或交易所發行的平台幣。 DeFi 去中心化金融DeFi 為 Decentralized Finance 的縮寫，解釋為建立在區塊鏈技術上的金融服務，如買賣、借貸、保險。 因為具有去中心化的特性，交易雙方可進行不受監管的金融活動，也因此不少人認為有其風險，是近年討論度非常高的加密貨幣機制。 對應傳統的中心化金融服務即為 CeFi（Centralize Finance）。 DeFi是什麼？去中心化金融DeFi跟CeFi差別在哪？DeFi 野蠻生長，法規監管跟得上「幣圈華爾街」的技術突破速度嗎？ PoW 工作量證明Proof of Work。利用電腦算力爭取驗證下一個區塊鏈的節點。工作量越大，得到的挖礦獎勵越多。 比特幣、以太坊 1.0 即是使用 PoW 這種機制，因為耗電量大、過度消耗硬體資源進而發展 PoS。 PoS 權益證明Proof of Stake。採取 PoS 機制的區塊鏈，系統會根據質押的加密貨幣數量來選出下一個區塊鏈結點的驗證者。質押的數量越多、時間越長，越有機會被選為驗證者。 以太坊 2.0、幣安幣即是採用 PoS 機制的區塊鏈，缺點為可能造成加幣貨幣囤積。 DPos 代理權益證明Delegated Proof of Stake。DPos 與 PoS 原理雷同，只是改為代理權益證明作為共識機制。與 PoS 的差異還有 DPoS 會票選出多個代理人，代理人將負責記帳和驗證。 擁有比 PoW、PoS 更高的效率、更低的功耗。但是以代理人共識取代全鏈共識的特性，有與區塊鏈去中心化的理念相違背的爭議。 桑幣知識+ 權益授權證明 DPoS (Delegated Proof of Stake) Staking 質押加密貨幣可以質押給驗證人，質押期間這些加密貨幣無法買賣交易。質押期間可以收取手續費，但依然要承受幣值浮動的風險。 每一種加密貨幣的質押規則、利息、解倉時間都不一定，各個交易所也會提供不同的衍生方式。 Perpetual 永續合約永續合約又稱合約、永續期貨合約。合約可以僅用小額度的保證金以槓桿的方式放大投資損益，而永續合約顧名思義只要不爆倉，該合約就一直有效。 爆倉：幣價漲跌幅 x 槓桿倍數 &gt; 100%。即合約終止，所有保證金歸零 一般在股市而言，期貨除了開槓桿加倍獲利也常用於避險，而加密貨幣交易的合約通常就是追求高倍數獲利之用。 腦哥 Chill塊鏈 虛擬貨幣合約交易操作解析","link":"/2021/12/26/question-about-crypto/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"front-end","slug":"front-end","link":"/tags/front-end/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"}],"categories":[{"name":"front-end","slug":"front-end","link":"/categories/front-end/"},{"name":"crypto","slug":"crypto","link":"/categories/crypto/"}]}